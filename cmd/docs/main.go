package main

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"gopkg.in/yaml.v3"
)

// Rule represents a single detection rule
type Rule struct {
	Name        string              `yaml:"name"`
	ID          string              `yaml:"id"`
	Description string              `yaml:"description"`
	Tags        []string            `yaml:"tags"`
	Pattern     string              `yaml:"pattern"`
	Redact      []int               `yaml:"redact"`
	Entropy     float64             `yaml:"entropy"`
	Tests       map[string][]string `yaml:"tests"`
}

// RuleFile represents the structure of a YAML rule file
type RuleFile struct {
	Rules []Rule `yaml:"rules"`
}

// Generate a markdown table of all rules in the rules directory
func main() {
	// Read all YAML files from the rules directory
	ruleFiles, err := os.ReadDir("rules")
	if err != nil {
		log.Fatal(err)
	}

	var allRules []Rule

	// Parse each YAML file
	for _, file := range ruleFiles {
		if !strings.HasSuffix(file.Name(), ".yaml") && !strings.HasSuffix(file.Name(), ".yml") {
			continue
		}

		filePath := filepath.Join("rules", file.Name())
		data, err := os.ReadFile(filePath)
		if err != nil {
			log.Printf("Error reading file %s: %v", filePath, err)
			continue
		}

		var ruleFile RuleFile
		if err := yaml.Unmarshal(data, &ruleFile); err != nil {
			log.Printf("Error parsing YAML file %s: %v", filePath, err)
			continue
		}

		allRules = append(allRules, ruleFile.Rules...)
	}

	// Sort rules by ID for consistent output
	sort.Slice(allRules, func(i, j int) bool {
		return allRules[i].ID < allRules[j].ID
	})

	// Generate markdown output
	generateMarkdown(allRules)
}

func generateMarkdown(rules []Rule) {
	fmt.Printf("# Poltergeist Rules Documentation\n\n")

	fmt.Printf("Auto-generated by `make docs`\n\n")

	fmt.Printf("Total rules: %d\n\n", len(rules))

	// Generate table header
	fmt.Printf("| Name | ID | Description | Tags | Entropy |\n")
	fmt.Printf("|------|----|-----------|----|---------|\n")

	// Generate table rows
	for _, rule := range rules {
		// Format tags
		tags := strings.Join(rule.Tags, ", ")
		if tags == "" {
			tags = "-"
		}

		// Format entropy
		entropy := fmt.Sprintf("%.1f", rule.Entropy)

		// Clean up description for markdown (remove newlines, escape pipes)
		description := strings.ReplaceAll(rule.Description, "\n", " ")
		description = strings.ReplaceAll(description, "|", "\\|")
		description = strings.TrimSpace(description)

		fmt.Printf("| [%s](#%s) | %s | %s | %s | %s |\n",
			rule.Name,
			rule.ID,
			rule.ID,
			description,
			tags,
			entropy,
		)
	}

	fmt.Printf("\n## Rule Details\n\n")

	// Generate detailed sections for each rule
	for _, rule := range rules {
		fmt.Printf("<a id=\"%s\"></a>\n### %s\n\n", rule.ID, rule.Name)
		fmt.Printf("**ID:** `%s`\n\n", rule.ID)
		fmt.Printf("**Description:** %s\n\n", rule.Description)

		if len(rule.Tags) > 0 {
			fmt.Printf("**Tags:** %s\n\n", strings.Join(rule.Tags, ", "))
		}

		// Format pattern
		fmt.Printf("**Pattern:**\n```\n%s\n```\n\n", rule.Pattern)

		fmt.Printf("**Min entropy:** %.1f\n\n", rule.Entropy)

		if len(rule.Tests) > 0 {
			fmt.Printf("**Tests:**\n")
			// Sort test types for consistent output
			var testTypes []string
			for testType := range rule.Tests {
				testTypes = append(testTypes, testType)
			}
			sort.Strings(testTypes)

			for _, testType := range testTypes {
				tests := rule.Tests[testType]
				fmt.Printf("- %s: %d cases\n", testType, len(tests))
			}
			fmt.Printf("\n")
		}

		fmt.Printf("\n")
	}
}
